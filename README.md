
# Отчёт по проекту Custom Thread Pool

## 1. Описание проекта и структура

**Цель проекта:**  
Разработать собственный пул потоков (`CustomThreadPoolExecutor`) с возможностью тонкой настройки параметров (количество потоков, размер очереди, резерв, время жизни), логированием ключевых событий и гибкой политикой отказа, а затем сравнить его производительность с пулом из стандартной библиотеки.

**Структура проекта:**
```
org.threadPool/
├── CustomExecutor.java                   — интерфейс пула потоков
├── CustomRejectedExecutionHandler.java   — политика отказа CallerRuns
├── CustomThreadFactory.java              — фабрика потоков с уникальными именами
├── CustomThreadPoolExecutor.java         — реализация пула
├── Worker.java                           — логика выполнения задач воркером
├── CustomPoolTest.java                   — тесты нагрузки на CustomThreadPoolExecutor
└── FixedPoolTest.java                    — тесты нагрузки на FixedThreadPool(10)
```

## 2. Что реализовано

- **Интерфейс `CustomExecutor`**  
  Поддерживает методы `execute(Runnable)`, `submit(Callable<T>)`, а также `shutdown()` и `shutdownNow()`.

- **Пользовательская политика отказа**  
  `CustomRejectedExecutionHandler` реализует `CallerRunsPolicy`, выполняя задачи в вызывающем потоке при переполнении.

- **Кастомная фабрика потоков**  
  `CustomThreadFactory` присваивает потокам имена `<PoolName>-worker-<N>` и логирует создание.

- **Основной пул `CustomThreadPoolExecutor`**  
  - Параметры:  
    - `corePoolSize` – минимальное число потоков  
    - `maxPoolSize` – максимальное число потоков  
    - `keepAliveTime` – время жизни лишних потоков  
    - `queueSize` – размер каждой из N очередей  
    - `minSpareThreads` – резерв свободных потоков  
  - **Round-Robin** распределение по N очередям  
  - Динамическое масштабирование и поддержание резерва  
  - Логирование и graceful/force shutdown

## 3. Анализ производительности

**Условия:**  
- Задачи: 10 000  
- `sleep(10–100 ms)`  
- Таймаут: 60 с  

| Пул                                    | Время (ms) | Tasks/sec | Латентность (ms) min・avg・max |
|----------------------------------------|------------|-----------|--------------------------------|
| **CustomThreadPoolExecutor (2-10-12-1)** | 51 334     | 194,80    | 10・55,18・101                 |
| **FixedThreadPool(10)**                | 55 359     | 180,64    | 10・54,87・101                 |

- CustomPool показал на **8 % выше throughput**, благодаря независимым очередям и снижению конкуренции.
- Средняя латентность обоих пулов сопоставима.

## 4. Принцип распределения задач (Round-Robin)

- Есть N = `maxPoolSize` очередей `BlockingQueue<Runnable>`.
- Индекс очереди = `(nextQueue++) % N`.
- Задачи равномерно распределяются без глобальных блокировок.
- В сочетании с динамическим масштабированием обеспечивает высокую параллельную пропускную способность.

## 5. Рекомендации

1. `corePoolSize` ≈ числу ядер (2).  
2. `maxPoolSize` ≈ 2–3× core.  
3. `queueSize` ≈ 4–8 × core.  
4. `minSpareThreads` = 1.  
5. Round-Robin снижает contention при больших объёмах задач.

> Проект показал, что кастомный пул с несколькими очередями и стратегией отказа может не только сравниться со стандартным пулом, но и превзойти его при высокой нагрузке.
